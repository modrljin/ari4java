package ch.loway.oss.ari4java.generated.ari_4_0_0.actions;

// ----------------------------------------------------
//      THIS CLASS WAS GENERATED AUTOMATICALLY         
//               PLEASE DO NOT EDIT                    
//    Generated on: Fri Oct 04 11:51:53 CEST 2019
// ----------------------------------------------------

import ch.loway.oss.ari4java.generated.Module;
import ch.loway.oss.ari4java.generated.*;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import ch.loway.oss.ari4java.tools.BaseAriAction;
import ch.loway.oss.ari4java.tools.RestException;
import ch.loway.oss.ari4java.tools.AriCallback;
import ch.loway.oss.ari4java.tools.HttpParam;
import ch.loway.oss.ari4java.tools.HttpResponse;
import com.fasterxml.jackson.core.type.TypeReference;
import ch.loway.oss.ari4java.generated.ari_4_0_0.models.*;

/**********************************************************
 * 
 * Generated by: Apis
 *********************************************************/


public class ActionApplications_impl_ari_4_0_0 extends BaseAriAction  implements ActionApplications {
/**********************************************************
 * Stasis applications
 * 
 * List all applications.
 *********************************************************/
private void buildList() {
reset();
url = "/applications";
method = "GET";
}

@Override
public List<Application> list() throws RestException {
buildList();
String json = httpActionSync();
return deserializeJsonAsAbstractList( json,
   new TypeReference<List<Application_impl_ari_4_0_0>>() {} ); 
}

@Override
public void list(AriCallback<List<Application>> callback) {
buildList();
httpActionAsync(callback, new TypeReference<List<Application_impl_ari_4_0_0>>() {});
}

/**********************************************************
 * Stasis application
 * 
 * Get details of an application.
 *********************************************************/
private void buildGet(String applicationName) {
reset();
url = "/applications/" + applicationName + "";
method = "GET";
lE.add( HttpResponse.build( 404, "Application does not exist.") );
}

@Override
public Application get(String applicationName) throws RestException {
buildGet(applicationName);
String json = httpActionSync();
return deserializeJson( json, Application_impl_ari_4_0_0.class ); 
}

@Override
public void get(String applicationName, AriCallback<Application> callback) {
buildGet(applicationName);
httpActionAsync(callback, Application_impl_ari_4_0_0.class);
}

/**********************************************************
 * Stasis application
 * 
 * Filter application events types.
 * Allowed and/or disallowed event type filtering can be done. The body (parameter) should specify a JSON key/value object that describes the type of event filtering needed. One, or both of the following keys can be designated:<br /><br />"allowed" - Specifies an allowed list of event types<br />"disallowed" - Specifies a disallowed list of event types<br /><br />Further, each of those key's value should be a JSON array that holds zero, or more JSON key/value objects. Each of these objects must contain the following key with an associated value:<br /><br />"type" - The type name of the event to filter<br /><br />The value must be the string name (case sensitive) of the event type that needs filtering. For example:<br /><br />{ "allowed": [ { "type": "StasisStart" }, { "type": "StasisEnd" } ] }<br /><br />As this specifies only an allowed list, then only those two event type messages are sent to the application. No other event messages are sent.<br /><br />The following rules apply:<br /><br />* If the body is empty, both the allowed and disallowed filters are set empty.<br />* If both list types are given then both are set to their respective values (note, specifying an empty array for a given type sets that type to empty).<br />* If only one list type is given then only that type is set. The other type is not updated.<br />* An empty "allowed" list means all events are allowed.<br />* An empty "disallowed" list means no events are disallowed.<br />* Disallowed events take precedence over allowed events if the event type is specified in both lists.
 *********************************************************/
private void buildFilter(String applicationName, String filter) {
reset();
url = "/applications/" + applicationName + "/eventFilter";
method = "PUT";
lParamBody.add( HttpParam.build( "filter", filter) );
lE.add( HttpResponse.build( 400, "Bad request.") );
lE.add( HttpResponse.build( 404, "Application does not exist.") );
}

@Override
public Application filter(String applicationName, String filter) throws RestException {
buildFilter(applicationName, filter);
String json = httpActionSync();
return deserializeJson( json, Application_impl_ari_4_0_0.class ); 
}

@Override
public void filter(String applicationName, String filter, AriCallback<Application> callback) {
buildFilter(applicationName, filter);
httpActionAsync(callback, Application_impl_ari_4_0_0.class);
}

/**********************************************************
 * Stasis application
 * 
 * Subscribe an application to a event source.
 * Returns the state of the application after the subscriptions have changed
 *********************************************************/
private void buildSubscribe(String applicationName, String eventSource) {
reset();
url = "/applications/" + applicationName + "/subscription";
method = "POST";
lParamQuery.add( HttpParam.build( "eventSource", eventSource) );
lE.add( HttpResponse.build( 400, "Missing parameter.") );
lE.add( HttpResponse.build( 404, "Application does not exist.") );
lE.add( HttpResponse.build( 422, "Event source does not exist.") );
}

@Override
public Application subscribe(String applicationName, String eventSource) throws RestException {
buildSubscribe(applicationName, eventSource);
String json = httpActionSync();
return deserializeJson( json, Application_impl_ari_4_0_0.class ); 
}

@Override
public void subscribe(String applicationName, String eventSource, AriCallback<Application> callback) {
buildSubscribe(applicationName, eventSource);
httpActionAsync(callback, Application_impl_ari_4_0_0.class);
}

/**********************************************************
 * Stasis application
 * 
 * Unsubscribe an application from an event source.
 * Returns the state of the application after the subscriptions have changed
 *********************************************************/
private void buildUnsubscribe(String applicationName, String eventSource) {
reset();
url = "/applications/" + applicationName + "/subscription";
method = "DELETE";
lParamQuery.add( HttpParam.build( "eventSource", eventSource) );
lE.add( HttpResponse.build( 400, "Missing parameter; event source scheme not recognized.") );
lE.add( HttpResponse.build( 404, "Application does not exist.") );
lE.add( HttpResponse.build( 409, "Application not subscribed to event source.") );
lE.add( HttpResponse.build( 422, "Event source does not exist.") );
}

@Override
public Application unsubscribe(String applicationName, String eventSource) throws RestException {
buildUnsubscribe(applicationName, eventSource);
String json = httpActionSync();
return deserializeJson( json, Application_impl_ari_4_0_0.class ); 
}

@Override
public void unsubscribe(String applicationName, String eventSource, AriCallback<Application> callback) {
buildUnsubscribe(applicationName, eventSource);
httpActionAsync(callback, Application_impl_ari_4_0_0.class);
}

/** No missing signatures from interface */
};

